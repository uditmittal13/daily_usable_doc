##Node Affinity v/s Pod affinity/anti-affinity

One-line summary
Affinity brings pods closer; anti-affinity pushes pods apart â€” MongoDB needs anti-affinity for high availability

**Pod affinity tells Kubernetes to schedule a pod close to (or on the same node/zone as) other specific pods based on labels.**
**Pod anti-affinity tells Kubernetes to schedule a pod away from other specific pods (based on labels), ensuring they donâ€™t run on the same node or zone.**

Node affinity restricts MongoDB pods to specific worker nodes based on node labels, ensuring performance, isolation, and compliance.
Node affinity tells Kubernetes:ðŸ‘‰ â€œThis pod can (or should) run only on certain nodes.â€
It controls which worker nodes a pod is allowed or preferred to be scheduled on

Also, there is no concept of node-anti-affinity.
Anti-affinityâ€ is only a pod-level concept
Nodes donâ€™t have â€œrelationshipsâ€ with other nodes â†’ hence no node anti-affinity object, 
But ðŸ‘ the behavior people usually mean by â€œnode anti-affinityâ€ does exist â€” itâ€™s achieved using node affinity with NotIn / DoesNotExist operators. 

Why Pod anti-affinity comes in pciture?
to achieve fault tolerance, high-availability, Survives in case of any node failure, Critical, keeps pods separate


##### Examples step by step:- ( yaml changes --or part to add in yaml)
A. Node Affinity :- Controls which nodes a pod can run on.
  Example: â€œRun MongoDB only on SSD nodes.â€

nodeAffinity:
  requiredDuringSchedulingIgnoredDuringExecution:
    nodeSelectorTerms:
    - matchExpressions:
      - key: disk
        operator: In
        values:
        - ssd

ðŸ”¹ B. Pod Affinity:- Controls which pods a pod should run with.
 Example: â€œRun app pods close to MongoDB pods.â€
podAffinity:
  requiredDuringSchedulingIgnoredDuringExecution:
  - labelSelector:
      matchLabels:
        app: mongodb
    topologyKey: kubernetes.io/hostname

ðŸ”¹ C. Pod Anti-Affinity :- Controls which pods a pod should run away from.
Example: â€œNever place two MongoDB replicas on the same node.â€

podAntiAffinity:
  requiredDuringSchedulingIgnoredDuringExecution:
  - labelSelector:
      matchLabels:
        app: mongo-test
    topologyKey: kubernetes.io/hostname

What this means ( understanding of terms used in pod anti affinity)
--requiredâ€¦ â†’ hard rule  , prefered -> soft rule
--kubernetes.io/hostname â†’ one pod per node    ( very important term passed in topologykey , 'kubernetes.io/hostname' is the label attached with each node having node ipaddess)
--app: mongo-test â†’ applies only to this ReplicaSet


### Why we still use stateful set for pod anti-affinity-   One-line summary (again, distilled)
Pod anti-affinity is configured under statefulSet because MongoDBCommunity is an abstraction, and the actual MongoDB pods are created and scheduled by a StatefulSet managed by the operator.



### What does READY 2/2 mean , when execute kubectl get pods -n namespace?
mongo-test-0   2/2   Running
READY = <ready containers> / <total containers in the pod>
    Why MongoDB pods have 2 containers
    MongoDB operator pods usually contain:
    Container   	     Purpose
    mongod	           MongoDB database process
    mongodb-agent	     Automation / monitoring age

### how to validate pod running on which node ???
Just need to add -o wide at the end of pods command , i will show Ip and node name
kubectl get pods -n namespace -o wide




#### how to manage node availability for maintenance ??? ( Cordon/Uncordon/drain)
In Kubernetes, cordon, uncordon, and drain are commands to manage node availability for maintenance: cordon marks a node as unschedulable (no new pods, existing run), drain cordons and then gracefully evicts all pods (except DaemonSets) for shutdown/upgrade, and uncordon reverses a cordon, making the node schedulable again

